/**
 * @file   crossbar_cqasm_compiler.h
 * @date   01/2019
 * @author Alejandro Morais
 * @brief  Crossbar cqasm compiler implementation
 */

#ifndef QL_CROSSBAR_QASM_COMPILER_H
#define QL_CROSSBAR_QASM_COMPILER_H

#include <ql/utils.h>
#include <ql/platform.h>
#include <ql/kernel.h>
#include <ql/gate.h>
#include <ql/ir.h>
#include <ql/eqasm_compiler.h>
#include <ql/arch/crossbar/crossbar_scheduler.h>

namespace ql
{
namespace arch
{
namespace crossbar
{

/**
 * Crossbar qasm compiler
 */
class crossbar_qasm_compiler : public eqasm_compiler
{
public:
    
    size_t num_qubits;
    size_t ns_per_cycle;

public:
    
    /**
     * Program-level compilation of qasm to crossbar_qasm
     */
    void compile(std::string prog_name, ql::circuit& ckt, ql::quantum_platform& platform)
    {
        EOUT("This compile method is not supported for the Crossbar platform");
    }

    /**
    * Compile a list of kernels
    */
    void compile(std::string prog_name, std::vector<quantum_kernel> kernels, const ql::quantum_platform& platform)
    {
        DOUT("Compiling " << kernels.size() << " kernels to generate Crossbar cQASM ... ");

        load_hw_settings(platform);

        std::stringstream qasm_ins_str;
        for (auto &kernel : kernels)
        {
            IOUT("Compiling kernel: " << kernel.name);
            ql::circuit& ckt = kernel.c;
            if (!ckt.empty())
            {
                // Schedule with platform resource constraints
                ql::ir::bundles_t bundles = crossbar_scheduler::schedule_rc(ckt, platform, num_qubits);

                // Convert to string
                qasm_ins_str << "" + ql::ir::qasm(bundles) + "\n";
            }
        }

        std::string file_name = "" + prog_name + "_compiled";
        IOUT("Writing Crossbar cQASM compiled to " + file_name);
        write_to_file(file_name, qasm_ins_str.str());

        DOUT("Compilation of Crossbar cQASM done");
    }

private:
    
    /**
    * Load the hardware settings
    */
    void load_hw_settings(const ql::quantum_platform& platform)
    {
        DOUT("Loading hardware settings ...");
        std::string params[] = {"qubit_number", "cycle_time"};
        size_t p = 0;
        try
        {
            num_qubits = platform.hardware_settings[params[p++]];
            ns_per_cycle = platform.hardware_settings[params[p++]];
        }
        catch (json::exception e)
        {
            throw ql::exception("Error while reading hardware settings: parameter '" + params[p - 1] + "'\n\t" + std::string(e.what()), false);
        }
    }

    /**
    * Write string to file
    */
    void write_to_file(std::string file_name, std::string ins_str)
    {
        std::string qasm_content("version 1.0\n");
        qasm_content += "# this file has been automatically generated by the OpenQL compiler please do not modify it manually.\n";
        qasm_content += "qubits " + std::to_string(num_qubits) + "\n\n";
        qasm_content += ".all_kernels";
        qasm_content += ins_str;
        
        std::ofstream fout;
        std::string file_path(ql::options::get("output_dir") + "/" + file_name + ".qasm");
        fout.open(file_path, ios::binary);
        if (fout.fail())
        {
            EOUT("Opening file " << file_name << std::endl
                << "Make sure the directory ("<< ql::options::get("output_dir") << ") exists");
            return;
        }
        fout << qasm_content << endl;
        fout.close();
    }
};

}
}
}

#endif // QL_CROSSBAR_QASM_COMPILER_H
